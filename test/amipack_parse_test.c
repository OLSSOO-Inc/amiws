#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <cmocka.h>

#include <stdio.h>

#include "amipack.h"

#define RV_SUCCESS 1
#define RV_FAIL !RV_SUCCESS

static void parse_prompt_header_11 (void **state)
{
  (void)*state;
  const char *str = "Asterisk Call Manager/1.1\r\n";
  AMIVer ver;
  int ret = amiparse_prompt (str, &ver);
  assert_int_equal (1, ret);
  assert_int_equal (1, ver.major);
  assert_int_equal (1, ver.minor);
  assert_int_equal (0, ver.patch);
}

static void parse_prompt_header_280 (void **state)
{
  (void)*state;
  const char *str = "Asterisk Call Manager/2.8.4\r\n";
  AMIVer ver;
  int ret = amiparse_prompt (str, &ver);
  assert_int_equal (1, ret);
  assert_int_equal (2, ver.major);
  assert_int_equal (8, ver.minor);
  assert_int_equal (4, ver.patch);
}

static void parse_not_prompt_pack (void **state)
{
  (void)*state;
  const char *str = "Response: Success\r\n";
  AMIVer ver;
  int ret = amiparse_prompt (str, &ver);
  assert_int_equal (0, ret);
  assert_int_equal (0, ver.major);
  assert_int_equal (0, ver.minor);
  assert_int_equal (0, ver.patch);
}

static void parse_action_one_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  int ret;
  size_t len;
  char *hv; // header value
  const char *str = "Action: CoreStatus\r\n\r\n";

  pack = amiparse_pack (str);
  assert_int_equal (AMI_ACTION, pack->type);
  assert_int_equal (pack->size, 1);
  len = amiheader_find(pack, "Action", &hv);
  assert_string_equal(hv, "CoreStatus");
  amipack_destroy (pack);
}

static void parse_event_one_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value
  const char *str = "Event: FullyBooted\r\n\r\n";

  pack = amiparse_pack (str);
  assert_int_equal (pack->type, AMI_EVENT);
  assert_int_equal (pack->size, 1);
  len = amiheader_find(pack, "Event", &hv);
  assert_string_equal(hv, "FullyBooted");
  amipack_destroy (pack);
}

static void parse_response_one_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value
  const char *str = "Response: Success\r\n\r\n";

  pack = amiparse_pack (str);
  assert_int_equal (pack->type, AMI_RESPONSE);
  assert_int_equal (pack->size, 1);
  len = amiheader_find(pack, "Response", &hv);
  assert_string_equal(hv, "Success");
  amipack_destroy (pack);
}

static void parse_invalid_pack (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value
  const char *str = "invalid pack that match stanza\r\n\r\n";

  pack = amiparse_pack (str);
  assert_null (pack);
}

static void parse_response_one_header_caseinsen (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value
  const char *str = "response: Fail\r\n\r\n";

  pack = amiparse_pack (str);
  assert_int_equal (pack->type, AMI_RESPONSE);
  assert_int_equal (pack->size, 1);
  len = amiheader_find(pack, "Response", &hv);
  assert_string_equal(hv, "Fail");
  amipack_destroy (pack);
}

static void parse_multi_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value

  // "Event: Hangup\r\n"
  // "Privilege: call,all\r\n"
  // "Channel: SIP/ipauthTp3BCHH7-00573401\r\n"
  // "Uniqueid: 1486254977.6071371\r\n"
  // "CallerIDNum: 18072280333\r\n"
  // "CallerIDName: <unknown>\r\n"
  // "ConnectedLineNum: 16478472022\r\n"
  // "ConnectedLineName: John Bar\r\n"
  // "Cause: 16\r\n"
  // "Cause-txt: Normal Clearing\r\n\r\n";
  const char str_pack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x48,0x61,0x6e,0x67,0x75,0x70,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x63,0x61,0x6c,0x6c,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x3a,0x20,0x53,0x49,0x50,0x2f,0x69,0x70,0x61,0x75,0x74,0x68,0x54,0x70,0x33,0x42,0x43,0x48,0x48,0x37,0x2d,0x30,0x30,0x35,0x37,0x33,0x34,0x30,0x31,0x0d,0x0a,0x55,0x6e,0x69,0x71,0x75,0x65,0x69,0x64,0x3a,0x20,0x31,0x34,0x38,0x36,0x32,0x35,0x34,0x39,0x37,0x37,0x2e,0x36,0x30,0x37,0x31,0x33,0x37,0x31,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x65,0x72,0x49,0x44,0x4e,0x75,0x6d,0x3a,0x20,0x31,0x38,0x30,0x37,0x32,0x32,0x38,0x30,0x33,0x33,0x33,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x65,0x72,0x49,0x44,0x4e,0x61,0x6d,0x65,0x3a,0x20,0x3c,0x75,0x6e,0x6b,0x6e,0x6f,0x77,0x6e,0x3e,0x0d,0x0a,0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x65,0x64,0x4c,0x69,0x6e,0x65,0x4e,0x75,0x6d,0x3a,0x20,0x31,0x36,0x34,0x37,0x38,0x34,0x37,0x32,0x30,0x32,0x32,0x0d,0x0a,0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x65,0x64,0x4c,0x69,0x6e,0x65,0x4e,0x61,0x6d,0x65,0x3a,0x20,0x4a,0x6f,0x68,0x6e,0x20,0x42,0x61,0x72,0x0d,0x0a,0x43,0x61,0x75,0x73,0x65,0x3a,0x20,0x31,0x36,0x0d,0x0a,0x43,0x61,0x75,0x73,0x65,0x2d,0x74,0x78,0x74,0x3a,0x20,0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x20,0x43,0x6c,0x65,0x61,0x72,0x69,0x6e,0x67,0x0d,0x0a,0x0d,0x0a};

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_EVENT, pack->type);
  assert_int_equal (pack->size, 10);

  len = amiheader_find(pack, "Event", &hv);
  assert_memory_equal (hv, "Hangup", len);

  len = amiheader_find(pack, "Privilege", &hv);
  assert_memory_equal (hv, "call,all", len);

  len = amiheader_find(pack, "Channel", &hv);
  assert_memory_equal (hv, "SIP/ipauthTp3BCHH7-00573401", len);

  len = amiheader_find(pack, "Uniqueid", &hv);
  assert_memory_equal (hv, "1486254977.6071371", len);

  len = amiheader_find(pack, "CallerIDNum", &hv);
  assert_memory_equal (hv, "18072280333", len);

  len = amiheader_find(pack, "CallerIDName", &hv);
  assert_memory_equal (hv, "<unknown>", len);

  len = amiheader_find(pack, "ConnectedLineNum", &hv);
  assert_memory_equal (hv, "16478472022", len);

  len = amiheader_find(pack, "ConnectedLineName", &hv);
  assert_memory_equal (hv, "John Bar", len);

  len = amiheader_find(pack, "Cause", &hv);
  assert_memory_equal (hv, "16", len);

  len = amiheader_find(pack, "Cause-txt", &hv);
  assert_memory_equal (hv, "Normal Clearing", len);

  amipack_destroy (pack);
}

static void parse_headers_with_empty_value (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value

  // "Event: Newchannel\r\n"
  // "Privilege: call,all\r\n"
  // "Channel: SIP/ipauthTp3BCHH7-00573539\r\n"
  // "ChannelState: 0\r\n"
  // "ChannelStateDesc: Down\r\n"
  // "CallerIDNum: \r\n"
  // "CallerIDName: \r\n"
  // "AccountCode: 81\r\n"
  // "Exten: \r\n"
  // "Context: mor\r\n"
  // "Uniqueid: 1486256739.6071687\r\n\r\n";
  const char str_pack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x4e,0x65,0x77,0x63,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x63,0x61,0x6c,0x6c,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x3a,0x20,0x53,0x49,0x50,0x2f,0x69,0x70,0x61,0x75,0x74,0x68,0x54,0x70,0x33,0x42,0x43,0x48,0x48,0x37,0x2d,0x30,0x30,0x35,0x37,0x33,0x35,0x33,0x39,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x53,0x74,0x61,0x74,0x65,0x3a,0x20,0x30,0x0d,0x0a,0x43,0x68,0x61,0x6e,0x6e,0x65,0x6c,0x53,0x74,0x61,0x74,0x65,0x44,0x65,0x73,0x63,0x3a,0x20,0x44,0x6f,0x77,0x6e,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x65,0x72,0x49,0x44,0x4e,0x75,0x6d,0x3a,0x20,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x65,0x72,0x49,0x44,0x4e,0x61,0x6d,0x65,0x3a,0x20,0x0d,0x0a,0x41,0x63,0x63,0x6f,0x75,0x6e,0x74,0x43,0x6f,0x64,0x65,0x3a,0x20,0x38,0x31,0x0d,0x0a,0x45,0x78,0x74,0x65,0x6e,0x3a,0x20,0x0d,0x0a,0x43,0x6f,0x6e,0x74,0x65,0x78,0x74,0x3a,0x20,0x6d,0x6f,0x72,0x0d,0x0a,0x55,0x6e,0x69,0x71,0x75,0x65,0x69,0x64,0x3a,0x20,0x31,0x34,0x38,0x36,0x32,0x35,0x36,0x37,0x33,0x39,0x2e,0x36,0x30,0x37,0x31,0x36,0x38,0x37,0x0d,0x0a,0x0d,0x0a};

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_EVENT, pack->type);

  assert_int_equal (pack->size, 11);
  assert_int_equal (amipack_length(pack), sizeof(str_pack));

  len = amiheader_find(pack, "Event", &hv);
  assert_string_equal(hv, "Newchannel");

  len = amiheader_find(pack, "ChannelStateDesc", &hv);
  assert_string_equal(hv, "Down");

  len = amiheader_find(pack, "CallerIDNum", &hv);
  assert_string_equal(hv, "");

  len = amiheader_find(pack, "Exten", &hv);
  assert_string_equal(hv, "");

  len = amiheader_find(pack, "Uniqueid", &hv);
  assert_string_equal(hv, "1486256739.6071687");

  amipack_destroy (pack);
}

static void parse_pack_with_empty_last_header (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value

  // "Event: Custom\r\n"
  // "Privilege: call,all\r\n"
  // "Exten: \r\n"
  // "Peer: \r\n\r\n";
  const char str_pack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x43,0x75,0x73,0x74,0x6f,0x6d,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x63,0x61,0x6c,0x6c,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x45,0x78,0x74,0x65,0x6e,0x3a,0x20,0x0d,0x0a,0x50,0x65,0x65,0x72,0x3a,0x20,0x0d,0x0a,0x0d,0x0a};

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_EVENT, pack->type);

  assert_int_equal (pack->size, 4);
  assert_int_equal (amipack_length(pack), sizeof(str_pack));

  len = amiheader_find(pack, "Event", &hv);
  assert_string_equal(hv, "Custom");

  len = amiheader_find(pack, "Peer", &hv);
  assert_string_equal(hv, "");

  amipack_destroy (pack);
}

static void parse_pack_unordered (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value

  // "Status: Fully Booted\r\n"
  // "Exten: \r\n"
  // "Event: FullyBooted\r\n"
  // "Privilege: system,all\r\n\r\n";
  const char str_pack[] = {0x53,0x74,0x61,0x74,0x75,0x73,0x3a,0x20,0x46,0x75,0x6c,0x6c,0x79,0x20,0x42,0x6f,0x6f,0x74,0x65,0x64,0x0d,0x0a,0x45,0x78,0x74,0x65,0x6e,0x3a,0x20,0x0d,0x0a,0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x46,0x75,0x6c,0x6c,0x79,0x42,0x6f,0x6f,0x74,0x65,0x64,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x0d,0x0a};

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_EVENT, pack->type);

  len = amiheader_find(pack, "Event", &hv);
  assert_string_equal(hv, "FullyBooted");

  amipack_destroy (pack);
}

static void parse_pack_with_invalid_header (void **state)
{
  (void)*state;
  AMIPacket *pack;

  // "Event: FullyBooted\r\n"
  // "invalid header\r\n"
  // "Exten: \r\n"
  // "Privilege: system,all\r\n\r\n";
  const char str_pack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x46,0x75,0x6c,0x6c,0x79,0x42,0x6f,0x6f,0x74,0x65,0x64,0x0d,0x0a,0x69,0x6e,0x76,0x61,0x6c,0x69,0x64,0x20,0x68,0x65,0x61,0x64,0x65,0x72,0x0d,0x0a,0x45,0x78,0x74,0x65,0x6e,0x3a,0x20,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,0x6c,0x65,0x67,0x65,0x3a,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x0d,0x0a};

  assert_null(amiparse_pack (str_pack));
}

static void parse_pack_command_output (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value

  const char str_pack[] = "Response: Follows\r\n"
                          "ActionID: 12345\r\n"
                          "Privilege: Command\r\n"
                          "Channel              Location             State   Application(Data)             \n"
                          "Local/5143607296@dia IVR_603@default:1    Up      AppDial((Outgoing Line))      \n"
                          "Local/5146020115@dia 5146020115@dial-foll Ring    Dial(SIP/5146020115@drspa.ntek\n"
                          "1754093 calls processed\n"
                          "--END COMMAND--\r\n\r\n";

  const char output_cmp[] = "Channel              Location             State   Application(Data)             \n"
                          "Local/5143607296@dia IVR_603@default:1    Up      AppDial((Outgoing Line))      \n"
                          "Local/5146020115@dia 5146020115@dial-foll Ring    Dial(SIP/5146020115@drspa.ntek\n"
                          "1754093 calls processed\n";

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_RESPONSE, pack->type);

  len = amiheader_find(pack, "Privilege", &hv);
  assert_string_equal(hv, "Command");

  len = amiheader_find(pack, "ActionID", &hv);
  assert_string_equal(hv, "12345");

  len = amiheader_find(pack, "Output", &hv);
  assert_string_equal(hv, output_cmp);

  amipack_destroy (pack);
}

// Command output compatibale with AMI v2
// Command output is a value of the header "Output: "
static void parse_pack_command_output_v2 (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *hv; // header value

  const char str_pack[] = "Response: Follows\r\n"
                          "Message: Command output follows\r\n"
                          "Output: Name/username             Host                                    Dyn Forcerport Comedia    ACL Port     Status      Description                      \r\n"
                          "8888/8888                 (Unspecified)                            D  Auto (No)  No             0        Unmonitored                                  \n"
                          "1 sip peers [Monitored: 0 online, 0 offline Unmonitored: 0 online, 1 offline]\n"
                          "--END COMMAND--\r\n\r\n";

  const char output_cmp[] = "Output: Name/username             Host                                    Dyn Forcerport Comedia    ACL Port     Status      Description                      \r\n"
                          "8888/8888                 (Unspecified)                            D  Auto (No)  No             0        Unmonitored                                  \n"
                          "1 sip peers [Monitored: 0 online, 0 offline Unmonitored: 0 online, 1 offline]\n";

  pack = amiparse_pack (str_pack);
  assert_int_equal (AMI_RESPONSE, pack->type);

  len = amiheader_find(pack, "Message", &hv);
  assert_string_equal(hv, "Command output follows");

  len = amiheader_find(pack, "Output", &hv);
  assert_string_equal(hv, output_cmp);

  amipack_destroy (pack);
}

static void parse_pack_with_multiple_unknown_headers (void **state)
{
  (void)*state;
  AMIPacket *pack;
  size_t len;
  char *pack_str;

  const char inpack[] = {0x45,0x76,0x65,0x6e,0x74,0x3a,0x20,0x53,0x75,0x63,0x63,0x65,0x73,0x73,0x66,0x75,0x6c,0x41,0x75,0x74,0x68,0x0d,0x0a,0x50,0x72,0x69,0x76,0x69,
    0x6c,0x65,0x67,0x65,0x3a,0x20,0x73,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x2c,0x61,0x6c,0x6c,0x0d,0x0a,0x45,0x76,0x65,0x6e,0x74,0x54,0x56,0x3a,
    0x20,0x32,0x30,0x31,0x37,0x2d,0x30,0x34,0x2d,0x30,0x32,0x54,0x31,0x35,0x3a,0x35,0x32,0x3a,0x30,0x38,0x2e,0x30,0x33,0x34,0x2d,0x30,0x34,0x30,
    0x30,0x0d,0x0a,0x53,0x65,0x76,0x65,0x72,0x69,0x74,0x79,0x3a,0x20,0x49,0x6e,0x66,0x6f,0x72,0x6d,0x61,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x0d,0x0a,
    0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x3a,0x20,0x41,0x4d,0x49,0x0d,0x0a,0x45,0x76,0x65,0x6e,0x74,0x56,0x65,0x72,0x73,0x69,0x6f,0x6e,0x3a,0x20,
    0x31,0x0d,0x0a,0x41,0x63,0x63,0x6f,0x75,0x6e,0x74,0x49,0x44,0x3a,0x20,0x61,0x64,0x6d,0x69,0x6e,0x0d,0x0a,0x53,0x65,0x73,0x73,0x69,0x6f,0x6e,
    0x49,0x44,0x3a,0x20,0x30,0x78,0x61,0x31,0x33,0x34,0x65,0x64,0x63,0x0d,0x0a,0x4c,0x6f,0x63,0x61,0x6c,0x41,0x64,0x64,0x72,0x65,0x73,0x73,0x3a,
    0x20,0x49,0x50,0x56,0x34,0x2f,0x54,0x43,0x50,0x2f,0x30,0x2e,0x30,0x2e,0x30,0x2e,0x30,0x2f,0x35,0x30,0x33,0x38,0x0d,0x0a,0x52,0x65,0x6d,0x6f,
    0x74,0x65,0x41,0x64,0x64,0x72,0x65,0x73,0x73,0x3a,0x20,0x49,0x50,0x56,0x34,0x2f,0x54,0x43,0x50,0x2f,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,
    0x31,0x2e,0x31,0x32,0x32,0x2f,0x35,0x30,0x34,0x34,0x38,0x0d,0x0a,0x55,0x73,0x69,0x6e,0x67,0x50,0x61,0x73,0x73,0x77,0x6f,0x72,0x64,0x3a,0x20,
    0x30,0x0d,0x0a,0x53,0x65,0x73,0x73,0x69,0x6f,0x6e,0x54,0x56,0x3a,0x20,0x32,0x30,0x31,0x37,0x2d,0x30,0x34,0x2d,0x30,0x32,0x54,0x31,0x35,0x3a,
    0x35,0x32,0x3a,0x30,0x38,0x2e,0x30,0x33,0x34,0x2d,0x30,0x34,0x30,0x30,0x0d,0x0a,0x0d,0x0a};

  pack = amiparse_pack (inpack);
  assert_int_equal (AMI_EVENT, pack->type);

  len = amipack_to_str(pack, &pack_str);
  assert_memory_equal (pack_str, inpack, len);

  amipack_destroy (pack);
  free(pack_str);
}

int main(void)
{
  const struct CMUnitTest tests[] = {
    cmocka_unit_test (parse_prompt_header_11),
    cmocka_unit_test (parse_prompt_header_280),
    cmocka_unit_test (parse_not_prompt_pack),
    cmocka_unit_test (parse_action_one_header),
    cmocka_unit_test (parse_event_one_header),
    cmocka_unit_test (parse_response_one_header),
    cmocka_unit_test (parse_invalid_pack),
    cmocka_unit_test (parse_response_one_header_caseinsen),
    cmocka_unit_test (parse_multi_header),
    cmocka_unit_test (parse_headers_with_empty_value),
    cmocka_unit_test (parse_pack_with_empty_last_header),
    cmocka_unit_test (parse_pack_unordered),
    cmocka_unit_test (parse_pack_with_invalid_header),
    cmocka_unit_test (parse_pack_command_output),
    cmocka_unit_test (parse_pack_command_output_v2),
    cmocka_unit_test (parse_pack_with_multiple_unknown_headers),
  };

  cmocka_set_message_output(CM_OUTPUT_TAP);

  return cmocka_run_group_tests_name("Parse AMI package tests.", tests, NULL, NULL);
}
